<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commonwealth Demo</title>
    <style>
        h2 {
            margin: 0;
        }

        small {
            color: #494949;
        }

        #server {
            position: fixed;
            top: 0;
            right: 0;
            /* width: 200px; */
            height: 100vh;
            overflow: auto;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
        }

        #server pre {
            font-size: 0.7rem;
        }

    </style>
</head>
<body> 
    <h1>Commonwealth</h1>
    <h2 id="displayName"></h2>
    <small id="history"></small>
    <hr>
    <div id="log">
        <h3>Output Log</h3>
    </div>
    <div id="server">
        <h3>Server Log</h3>
    </div>
</body>

<script type="module">
    import * as commonwealth from './src/index.js'
    const service = new commonwealth.Service()

    import * as object from './demo/object.js'
    import { HTTPClient } from './src/http/client.js'

    const startTime = performance.now()

    let objectToUse = object // ESM With Side-Effects
    // let objectToUse = Object.assign({}, object) // Standard Object with Side-Effects

    // import { updateValue } from './demo/object.js'

    // Setup SSE
    const serverEl = document.getElementById('server')

    const http = new HTTPClient('http://localhost:3768')
 
    // Manage UI
    const headerEl = document.getElementById('displayName')
    const historyEl = document.getElementById('history')
    const logEl = document.getElementById('log')
    let elements = {}


    // Properly run updates in order
    let queue = []

    let active = false

    const runFromQueue = async (id, value) => {
        active = true
        try {
            const updatedValue = await http.set(id, value)
            const newValue = await http.get(id)
            const isValidResult = newValue == value && value == updatedValue
            if (!isValidResult)  console.error('Request failed', id, newValue, value, updatedValue)

        } catch (e) {
            console.error(e)
        }

        active = false
        const nextInQueue = queue.shift()
        if (nextInQueue) runFromQueue(nextInQueue.id, nextInQueue.value)
    }

    const addToQueue = async (id, value) => {
        if (!active) runFromQueue(id, value)
        else queue.push({id, value})
    }


    const logFunction = async function (value, ...args){
        const id = this[commonwealth.symbols.id]
        elements[id].innerHTML += `<pre>${(performance.now() - startTime).toFixed(2)}ms - ${JSON.stringify(value, null, 2)}</pre>`  // Display on Frontend
        
        // Check if name exists before sending
        if (id in http.service.endpoints) addToQueue(id, value) // Mirror on Backend
        else console.warn(`No endpoint found for ${id} on the server`)
    }
    
    service.add('log',  logFunction)

    service.add('self', service)


    const valueUpdated = (...args) => {
        const current = headerEl.innerHTML
        const previous = historyEl.innerHTML
        if (current) historyEl.innerHTML += previous ? ` > ${current}` : current

        headerEl.innerHTML = args[0]
    }

    const createElement = (name) => {
        const el = elements[name] = document.createElement('div')
        el.id = name
        el.innerHTML = `<h4>${name}</h4>`
        logEl.appendChild(el)
    }

    // Log updates from all endpoints on the frontend
    service.subscribe('self.add', function (registered) {
        const name = registered?.[commonwealth.symbols.id]
        if (name) {

            // Create UI element for each reigstered element
            if (!elements[name]) createElement(name)

            service.subscribe(name, 'log') // Subscribe between endpoints
        }
    })

    const nameRegistered = service.add('displayName', objectToUse.displayName, objectToUse) // Include parent
    const registeredUpdateFunction = service.add('updateDisplayName', objectToUse.updateDisplayName) // No need to include parent for functions
    const registeredObject = service.add('object', objectToUse)
    const targetIdPre = service.subscribe('displayName', valueUpdated)

    const runTest = () => {
        const internalArrayProxy = service.get('object.array')
        registeredObject.array.push(1) // NOTE: Does not yet work...
        internalArrayProxy.push(2)

        // objectToUse.updateDisplayName('Through Original Update') // Will not work on ESM with side-effects
        registeredUpdateFunction('Through Registered Update')
        
        // Both are resolved
        // objectToUse.displayName = 'On Original Object'
        service.set('displayName', 'With Set Method')
        registeredObject.displayName = 'On Registered Object'

        // Able to trigger on nested update function, though this targets a different value update
        objectToUse.nested.updateDisplayName('Nested User')

        // Reponse thrown when new property is set
        registeredObject.added = true 

        // Response thrown when new function is set
        registeredObject.listenable = () => true
        registeredObject.listenable()


        // Update Object Value Directly
        service.set('object.displayName', 'Batman')

        // Multiply Object Value with Function (async update)
        setTimeout(() => {
            service.set('object.updateDisplayName', 'Not Batman')

            // Remove Endpoints after use
            console.log('nEndpoints', Object.keys(service.endpoints).length)
            service.remove('object')
            console.log('nEndpoints (no object)', Object.keys(service.endpoints).length)
        }, 1000)
    }

    http.connect()
    
    // Subscribe to all initial properties (except self) on the server
    http.onopen = async () => {
        await Promise.all(Object.keys(service.endpoints).map((id) => {
            if (id.includes('self')) return // Skip self
            return http.subscribe(id, (update) => {
                serverEl.innerHTML += `<pre>${(performance.now() - startTime).toFixed(2)}ms - ${id} = ${update}</pre>`
            })
        }))

        http.add('echo')
        http.subscribe('echo', (update) => {
            serverEl.innerHTML += `<pre>ECHO ${(performance.now() - startTime).toFixed(2)}ms - ${update}</pre>`
        })
        
        const res = await http.set('echo', 'Hello World!')

        runTest()
    }

    // Just run tests if no server
    http.onerror = runTest

</script>
</html>