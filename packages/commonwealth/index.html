<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commonwealth Demo</title>
    <style>
        h2 {
            margin: 0;
        }

        small {
            color: #494949;
        }

        #server {
            position: fixed;
            top: 0;
            right: 0;
            /* width: 200px; */
            height: 100vh;
            overflow: auto;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
        }

        #server pre {
            font-size: 0.7rem;
        }

    </style>
</head>
<body> 
    <h1>Commonwealth</h1>
    <h2 id="displayName"></h2>
    <small id="history"></small>
    <hr>
    <div id="log">
        <h3>Output Log</h3>
    </div>
    <div id="server">
        <h3>Server Log</h3>
    </div>
</body>

<script type="module">
    import * as commonwealth from './src/index.js'
    const service = new commonwealth.Service()

    import * as object from './demo/object.js'

    const startTime = performance.now()

    let objectToUse = object // ESM With Side-Effects
    // let objectToUse = Object.assign({}, object) // Standard Object with Side-Effects

    // import { updateValue } from './demo/object.js'

    // Setup SSE
    const serverEl = document.getElementById('server')
    const serverURL = 'http://localhost:3768'
    const evtSource = new EventSource(`${serverURL}/subscribe`);
    evtSource.onmessage = (event) => {
        const json = JSON.parse(event.data)
        serverEl.innerHTML += `<pre>${(performance.now() - startTime).toFixed(2)}ms - ${json.id} = ${json.results}</pre>`
    };

    evtSource.onerror = (err) => console.error("EventSource failed:", err);


    // Manage UI
    const headerEl = document.getElementById('displayName')
    const historyEl = document.getElementById('history')
    const logEl = document.getElementById('log')
    let elements = {}
    const logFunction = async function (value, ...args){
        const id = this[commonwealth.symbols.id]
        // console.log(`[${id}]`, value, ...args)
        
        // Display on Frontend
        elements[id].innerHTML += `<pre>${(performance.now() - startTime).toFixed(2)}ms - ${JSON.stringify(value, null, 2)}</pre>`

        // Mirror on Backend
        const res = await fetch(`${serverURL}/${id.split('.').join('/')}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ args: [value] })
        })
        .then(res => res.json())
        .catch(e => {})
    }
    
    service.add('log',  logFunction)

    service.add('self', service)


    const updateValueCalled = (...args) => console.log('Update value has been called!', ...args)

    const valueUpdated = (...args) => {
        const current = headerEl.innerHTML
        const previous = historyEl.innerHTML
        if (current) historyEl.innerHTML += previous ? ` > ${current}` : current

        headerEl.innerHTML = args[0]
    }

    const listenableKeyAdded =(...args) =>  console.log('Is listened to!', ...args)

    const keyAdded = (...args) => console.log('Added!', ...args)

    // Listen to all registered objects
    service.subscribe('self.add', function (registered) {
        const name = registered?.[commonwealth.symbols.id]
        if (name) {

            // Create UI element for each reigstered element
            if (!elements[name]) {
                const el = elements[name] = document.createElement('div')
                el.id = name
                el.innerHTML = `<h4>${name}</h4>`
                logEl.appendChild(el)
            }

            service.subscribe(name, 'log') // Subscribe between endpoints
        }
    })

    const nameRegistered = service.add('displayName', objectToUse.displayName, objectToUse) // Include parent
    const registeredUpdateFunction = service.add('updateDisplayName', objectToUse.updateDisplayName) // No need to include parent for functions
    const registeredObject = service.add('object', objectToUse)

    const targetIdPre = service.subscribe('displayName', valueUpdated)
    const targetId = service.subscribe('updateDisplayName', updateValueCalled)
    const targetId2 = service.subscribe('object.displayName', valueUpdated)
    const targetId3 = service.subscribe('object.updateDisplayName', updateValueCalled) // Is an alias for the original method
    const targetId4 = service.subscribe('object.nested.updateDisplayName', updateValueCalled) // Is accessing a different this.displayName than the original method

    service.subscribe('object.listenable', listenableKeyAdded) // Is an alias for the original method
    service.subscribe('object.added', keyAdded) // Is an alias for the original method

    const runTest = () => {
        console.warn('----------- Test Subscriptions -----------')

        const internalArrayProxy = service.get('object.array')
        registeredObject.array.push(1) // NOTE: Does not yet work...
        internalArrayProxy.push(2)

        // objectToUse.updateDisplayName('Through Original Update') // Will not work on ESM with side-effects
        registeredUpdateFunction('Through Registered Update')

        console.log(service.endpoints)
        // Both are resolved
        // objectToUse.displayName = 'On Original Object'
        service.set('displayName', 'With Set Method')
        registeredObject.displayName = 'On Registered Object'

        // Update is still registered on an alias (objectToUse.displayName)
        service.unsubscribe('updateDisplayName', targetId)
        // objectToUse.updateDisplayName('Reset Name') // Will not work on ESM with side-effects
        registeredObject.updateDisplayName()

        // Able to trigger on nested update function, though this targets a different value update
        objectToUse.nested.updateDisplayName('Nested User')

        // No longer resolved once alias is removed
        service.unsubscribe('object.updateDisplayName', updateValueCalled)
        // objectToUse.updateDisplayName('What I Want') // Will not work on ESM with side-effects
        registeredObject.updateDisplayName('What I Want')

        // Reponse thrown when new property is set
        registeredObject.added = true 

        // Response thrown when new function is set
        registeredObject.listenable = () => true
        registeredObject.listenable()

        console.warn('----------- Get and Set Properties -----------')

        // Latest Object value
        console.log(service.get('object.displayName')) // 40

        // Update Object Value Directly
        service.set('object.displayName', 'Batman')
        console.log(service.get('object.displayName')) // 1000

        // Multiply Object Value with Function (async update)
        setTimeout(() => {
            service.set('object.updateDisplayName', 'Not Batman')
            console.log(service.get('object.displayName')) // 2000
        }, 1000)

        // console.warn('----------- Remove an Endpoint -----------')
        // console.log('nEndpoints', Object.keys(service.endpoints).length)
        // service.remove('object')
        // console.log('nEndpoints (no object)', Object.keys(service.endpoints).length)

    }

    evtSource.onopen = runTest

</script>
</html>